/*** Send request to firebase and get required data value.* @param 'ref' the firebase url (request)          'callbackValue' callback value needed in the calling method          'callback' the callback function*/function getFirebaseEntryValue(ref, callbackObj, callback) {  // Send request to firebase  new Firebase(ref).once('value', function(dataSnapshot) {  //callback    console.log(dataSnapshot.val());    callback(dataSnapshot.val(), callbackObj);  // callback with data retrieved  });}/*** Round number to nearest float num with two floating digits.* @param 'num' the float num to be rounded* @return the nearest float number with two floating digits*/function round(num) {  return Math.round(num*10)/10;}/*** Syllabifier class handles text syllabifications.*/Syllabifier = Class.$extend({  /**  * Initilize class variables (classy.js is used for class creation)  */  __init__: function() {    // configure Hyphenator    Hyphenator.config({      'minwordlength': 3,      'hyphenchar': '-'    });    this.firebaseRef = "https://readfm.firebaseio.com/syllableLookup/";  // firebase url    this.fbWordsSybs = {};    this.sourceText = null;    this.hyphenatedText = null;  },  setHyphenatedText: function(text) {    this.hyphenatedText = text;  },  /**  * Divide words into syllables separated by '-'  * Retrieve sybs of text words from firebase then hyphenate text.  * @param 'text' text to be syllabified           'callback' callback function to return to toggle.data  */  syllabifyText: function(text, callback) {    var i, word = "";    var syllabifier = this;    var isNewText = this.sourceText == null || this.sourceText != text;    if(isNewText) {      this.fbWordsSybs = {};      this.sourceText = text;      text = text.replace(/\-/g, '@');      var words = getStrWords(text);      for(i=0; i<words.length; i++) {        word = words[i].toLowerCase();        // Send request to firebase        getFirebaseEntryValue(this.firebaseRef+word, i, function(data, wordIx) {  //callback          syllabifier.fbWordsSybs[wordIx] = data;          if(Object.size(syllabifier.fbWordsSybs) == words.length) syllabifier.hyphenateText(text, callback);        });      }    } else {      callback(this.hyphenatedText);    }  },  /**  * Hyphenate text using Hyphenator.js and firebase lookup table.  * Hyphenate text using Hyphenator.js api, loop on hyphenated text words.  * If word has sybs on fb, then replace the hyphenated word got from hyphenator by the one got from fb.  * If word has no saved sybs on fb, then use the already hyphenated word and save it into fb.  * @param 'text' text to be hyphenated           'callback' callback function to return to toggle.data  * @return text hyphenated with '- '  */  hyphenateText: function(text, callback) {    var i, j, word, hword, fbhword, syllables;    text = Hyphenator.hyphenate(text, 'en');    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');  // remove zero width spaces that may inserted from the Hyphenator.js    var hwords = getStrWords(text);    for(i=0; i<hwords.length; i++) {      hword = hwords[i];      word = hword.replace(/\-/g, '');      if(this.fbWordsSybs[i]) { // there is a saved sybs of this word        syllables = this.fbWordsSybs[i].split('-');        fbhword = "";        j = 0;        $.each(syllables, function() {          fbhword = fbhword + word.substr(j, this.length) + '-';          j += this.length;        });        fbhword = fbhword.substring(0, fbhword.length-1); // Remove the last -        re = new RegExp(hword);        text = text.replace(re, fbhword);      } else { // no saved sybs of this word, keep the existing hyphenated word and save it to fb (if it's hyphenated)        if(word.indexOf('-') != -1) new Firebase(this.firebaseRef+word.toLowerCase()).set(hword.toLowerCase());      }    }    text = text.replace(/\@/g, '--'); // Add hyphen here    this.hyphenatedText = text; // cache of hyphenated text    callback(text);  },  /**  * Remove hyphens from text.  * @param 'hText' the hyphenated text  * @return orginal text  */  unsyllabifyText: function(hText) {    return hText.replace(/\--/g, '@').replace(/\-/g, '').replace(/\@/g, '-');  },  /**  * Insert '-' where the cursor points, and all other instances of the word.  * @param 'text' area input text, including timing lines           'caretCoord' cursor coordinates (line number and offset)  */  replaceByHyphenatedWord: function(text, caretCoord) {    text = text.replace(/\--/g, '@@'); // to differntiate dash separated words from hyphenated words    var cursorPos = caretCoord.offset;    var currentLine = text.split('\n')[caretCoord.lines];    var pair = this.wordHyphenationPair(currentLine, cursorPos);    if(pair) {      var word = pair[0].replace(/\-/g, '').toLowerCase();  // unsyllabified word      var hword = pair[1].toLowerCase();  // new syllabified word      new Firebase(this.firebaseRef+word).set(hword); // save word/syllables into firebase      var newText = this.updateTextWithHyphenatedWord(text, pair[0], pair[1]); //replace all instances of the word by its syllables      return newText.replace(/\@@/g, '--'); // return updated text    }    return null;  },  /**  * Get the pair of the word to hyphenate and its hyphenation using the position of hyphen.  * @param 'str' the input string           'pos' cursor position  * @return array of word before and after adding the hyphen, null if word not found  */  wordHyphenationPair: function(str, pos) {    var arr = wordAtCaret(str, pos);    if(arr) { // word found, character added/deleted is a -      var hword = arr[0];      var cursorIx = arr[1];      var word = hword.substring(0, cursorIx-1) + hword.slice(cursorIx);  // word before adding the -      return new Array(word, hword);    }    return null;  },  /**  * Update all instances of a word to its hyphenation.  * @param 'text' area input text, including timing lines           'word' word before adding -           'entry' word after adding -  */  updateTextWithHyphenatedWord: function(text, word, entry) {    var re, i, x, diff = 0, tmp = "";    re = new RegExp("\\b" + word + "(?!(-|'))\\b", 'gi');    var words = text.match(re);    var matches = matchIndices(text, re);    if(words) {  // If match is found.      var syllables = entry.split('-');      for(x=0; x<words.length; x++) {        i = 0;        entry = "";        tmp = words[x].replace(/\-/g, '');        $.each(syllables, function() {          entry = entry + tmp.substr(i, this.length) + '-';          i += this.length;        });        entry = entry.substring(0, entry.length-1);  // Remove the last -        if(text.charAt(matches[x]+diff-1) != "'" && text.charAt(matches[x]+diff-1) != "-") {          text = text.substring(0, matches[x]+diff) + entry + text.slice(matches[x]+diff+words[x].length);          diff += entry.length - words[x].length;        }           }    }    return $.trim(text);  },  /**  * Undo manually hyphenation made to a word, and update all its instances.  * @param 'text' area input text, including timing lines           'caretCoord' cursor coordinates (line number and offset)  */  undoHyphenation: function(text, caretCoord) {    text = text.replace(/\--/g, '@@'); // to differntiate dash separated words from hyphenated words    var cursorPos = caretCoord.offset;    var currentLine = text.split('\n')[caretCoord.lines];    var pair = this.wordHyphenationPair(currentLine, cursorPos);    if(pair) {      //text = " " + text + " ";      var word = pair[0].replace(/\-/g, '').toLowerCase();  // unsyllabified word      var hword = pair[0].indexOf('-') != -1 ? pair[0].toLowerCase() : null;  // new syllabified word      new Firebase(this.firebaseRef+word).set(hword); // save word/syllables into firebase      var newText = this.updateTextWithUnhyphenatedWord(text, pair[0], pair[1]);      return newText.replace(/\@@/g, '--');    }  },  /**  * Undo hyphenation from all instances of a word.  * @param 'text' input text           'word' the word after deleting -           'entry' the word before deleting -  */  updateTextWithUnhyphenatedWord: function(text, word, entry) {    var re, i, x, diff = 0, tmp = "";    re = new RegExp("\\b" + entry + "(?!(-|'))\\b", 'gi');    var entries = text.match(re);    var matches = matchIndices(text, re);    if(entries) {  // If match is found.      //var hyphenIndex = this.getHayphenIndex(word, entry);      var syllables = word.split('-');      for(x=0; x<entries.length; x++) {        i = 0;        entry = "";        tmp = entries[x].replace(/\-/g, '');        $.each(syllables, function() {          entry = entry + tmp.substr(i, this.length) + '-';          i += this.length;        });        entry = entry.substring(0, entry.length-1);  // Remove the last -        text = text.substring(0, matches[x]-diff) + entry + text.slice(matches[x]-diff+entries[x].length);        diff++;        //newEntry = entries[x].substring(0, hyphenIndex) + entries[x].slice(hyphenIndex+1);        //text = text.substring(0, matches[x]-diff) + newEntry + text.slice(matches[x]-diff+entries[x].length);        //console.log(text);        //diff++;             }    }    return $.trim(text);  }});/*** Timing class handles timing features.*/TimingCreator = Class.$extend({  /**  * Initilize class variables (classy.js is used for class creation)  */  __init__: function() {    this.timingLines = [];    this.sourceText = null;    this.firebaseRef = "https://readfm.firebaseio.com/foo/";  },  /**  * Get timing lines for text lines.  * Load timing lines from fb, create time slots for lines that does not have a saved entry.  * @param 'text' the input text           'hText' hyphenated text           'callback' callback function to return to toggle.data  * @retutn timing lines  */  getSegTiming: function(text, hText, callback) {    var z = 1, i, j, timing = "", segs = [], timingLines = [], words = [];    var timing = this;    var isNewText = this.sourceText == null || this.sourceText != text; // check if it's a new text    if(!isNewText) {  // old text, return cached timing      callback(this.timingLines);      return;    }    // Create timing slots for this new text    this.sourceText = text;    this.timingLines = [];    var lines = text.split('\n');    for(i=0; i<lines.length; i++) {      line = getStrWords(lines[i]).join('-');      getFirebaseEntryValue(this.firebaseRef+line+"/timing", i, function(data, lineIx) {  //callback        timing.timingLines[lineIx] = data;        if(timing.timingLines.length == lines.length) timing.fillTimings(hText, callback);      });    }  },  incompleteTimings: function() {    for(var i=0; i<this.timingLines.length; i++) {      if(!this.timingLines[i]) return true;    }    return false;  },  /**  * Create time slots for segments.  * @param 'hText' the hyphenated input text           'callback' callback function to return to toggle.data  * @retutn timing lines  */  fillTimings: function(hText, callback) {    var timer = this;    var z = 0.2, i, j, timing = "", segs = [], words = [], timingLines = [], zStr = "";    // If all timing lines loaded from firebase, then return loaded timings    if(!this.incompleteTimings()) {      callback(this.timingLines);      return;    }    // Create timing slots for this new text    var lines = hText.split('\n'); // hyphenated lines    for(i=0; i<lines.length; i++) {      // Create timing slots for this line      timing = "";      words = getStrWords(lines[i]);      for(j=0; j<words.length; j++) {        segs = words[j].split('-');        $.each(segs, function() {          if(this != "") {            zStr = timer.timingStr(z);            timing += zStr + " ";            z += 0.2;          }        });      }      timingLines[i] = $.trim(timing);    }    this.timingLines = timingLines;    callback(this.timingLines);  },  /**  * Put the timing floating number in the string form, display only two floating digits.  * @param 'timing' timing floating number  * @return timing string  */  timingStr: function(timing) {    var str = "";    timing = round(timing);  // round number to nearest float with 2 floating digits    var decParts = timing.toString().split('.');    var decimal = decParts[0];    var fraction = decParts[1];    if(fraction) {  // float number, one floating digit because of the round      str = timing + "0"; // concatenate 0 to display 2 floating digits    } else {  // integer "1, 2, 3, ...."      str = timing + ".00";    }    return str;  },  /**  * Save timing lines into firebase.  * @param 'text' the input text  */  saveTimings: function(text) {    var i, line = "";    var lines = text.split('\n');    for(i=0; i<lines.length; i++) {      line = getStrWords(lines[i]).join('-');      new Firebase(this.firebaseRef+line+"/timing").set(this.timingLines[i]); // save timing line    }  },  /**  * Get timing lines.  * @return timing lines of current text  */  getTimingLines: function() {    return this.timingLines;  },  /**  * Set timing lines.  * @param 'lines' new timing lines  */  setTimingLines: function(lines) {    this.timingLines = lines;  }});